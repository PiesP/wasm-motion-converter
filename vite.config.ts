/**
 * Vite Configuration
 *
 * Configures Vite build system for SolidJS application with:
 * - FFmpeg.wasm cross-origin isolation (SharedArrayBuffer support)
 * - Dynamic AdSense integration via environment variables
 * - Path aliases for cleaner imports
 * - Manual code splitting for optimal caching
 * - Bundle analysis via rollup-plugin-visualizer
 *
 * @see https://vite.dev/config/
 * @see CODE_STANDARDS.md Section 1 (File Organization)
 * @see AGENTS.md for FFmpeg SharedArrayBuffer requirements
 */
import {
  existsSync,
  mkdirSync,
  readFileSync,
  readdirSync,
  rmSync,
  unlinkSync,
  writeFileSync,
} from 'node:fs';
import path from 'node:path';
import { build as esbuild } from 'esbuild';
import { visualizer } from 'rollup-plugin-visualizer';
import type { Plugin, PluginOption } from 'vite';
import { defineConfig, loadEnv } from 'vite';
import solid from 'vite-plugin-solid';

/**
 * Reads runtime dependencies from package.json.
 *
 * This is used as the single source of truth for:
 * - Import map generation (CDN-based ESM loading)
 * - Rollup externalization (avoid bundling runtime deps)
 *
 * Runtime deps are sourced from:
 * - dependencies (installed runtime libs)
 * - cdnDependencies (CDN-only libs; not installed, but version-pinned)
 */
function readRuntimeDependencies(): Record<string, string> {
  const pkgJsonPath = path.join(process.cwd(), 'package.json');
  const raw = readFileSync(pkgJsonPath, 'utf-8');

  // biome-ignore lint/suspicious/noExplicitAny: package.json is untyped external input
  const pkg = JSON.parse(raw) as any;
  const deps = (pkg?.dependencies ?? {}) as Record<string, string>;
  const cdnDeps = (pkg?.cdnDependencies ?? {}) as Record<string, string>;

  const normalizeVersion = (spec: string): string =>
    String(spec)
      .trim()
      .replace(/^[\^~]/, '');

  const normalized: Record<string, string> = {};
  const addDeps = (source: Record<string, string>, label: string): void => {
    for (const [name, spec] of Object.entries(source)) {
      const version = normalizeVersion(spec);
      const existing = normalized[name];
      if (existing && existing !== version) {
        throw new Error(
          `[cdn-deps] Version mismatch for ${name}: ${existing} (previous) vs ${version} (${label})`
        );
      }

      // esm.sh/jsdelivr/unpkg URLs behave best with concrete versions.
      normalized[name] = version;
    }
  };

  addDeps(deps, 'dependencies');
  addDeps(cdnDeps, 'cdnDependencies');

  return normalized;
}

function injectRuntimeDepsIntoServiceWorker(code: string): string {
  const runtimeDeps = readRuntimeDependencies();
  const json = JSON.stringify(runtimeDeps);
  const escaped = json.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  const replaced = code.replaceAll('__RUNTIME_DEP_VERSIONS__', escaped);

  if (replaced === code) {
    console.warn('[cdn-deps] Service worker runtime dependency placeholder not replaced');
  }

  return replaced;
}

/**
 * Virtual module exposing consistent CDN URL builders for runtime code.
 *
 * This avoids hardcoding dependency versions in multiple places.
 * Consumers can use:
 * - esmShModuleUrl('comlink')
 * - esmShModuleUrl('@jsquash/webp', '/encode.js')
 * - esmShAssetUrl('@jsquash/webp', '/codec/enc/webp_enc.wasm')
 */
function cdnDepsVirtualModulePlugin(): Plugin {
  const virtualId = 'virtual:cdn-deps';
  const resolvedVirtualId = `\0${virtualId}`;

  const runtimeDeps = readRuntimeDependencies();
  const baseUrl = 'https://esm.sh';
  const target = 'esnext';

  return {
    name: 'cdn-deps-virtual-module',
    resolveId(id) {
      if (id === virtualId) {
        return resolvedVirtualId;
      }
      return undefined;
    },
    load(id) {
      if (id !== resolvedVirtualId) {
        return undefined;
      }

      // Note: this must be valid JavaScript (not TypeScript).
      return `// Generated by vite.config.ts (cdn-deps-virtual-module)
export const RUNTIME_DEP_VERSIONS = ${JSON.stringify(runtimeDeps, null, 2)};
export const ESM_SH_BASE_URL = ${JSON.stringify(baseUrl)};
export const ESM_SH_TARGET = ${JSON.stringify(target)};

/**
 * Unified CDN provider configuration (matches cdn-config.ts)
 * Used for runtime CDN operations and debugging
 */
export const CDN_PROVIDERS = [
  { name: 'esm.sh', hostname: 'esm.sh', baseUrl: 'https://esm.sh', priority: 1, timeout: 15000, enabled: true },
  { name: 'jsdelivr', hostname: 'cdn.jsdelivr.net', baseUrl: 'https://cdn.jsdelivr.net', priority: 2, timeout: 15000, enabled: true },
  { name: 'unpkg', hostname: 'unpkg.com', baseUrl: 'https://unpkg.com', priority: 3, timeout: 15000, enabled: true },
  { name: 'skypack', hostname: 'cdn.skypack.dev', baseUrl: 'https://cdn.skypack.dev', priority: 4, timeout: 15000, enabled: true },
];

/**
 * Gets all enabled CDN providers
 * @returns Array of enabled CDN providers
 */
export function getCDNProviders() {
  return CDN_PROVIDERS.filter(p => p.enabled);
}

function toQuery(params) {
  if (!params) return '';
  const entries = Object.entries(params).filter(([, v]) => v != null && v !== '');
  if (entries.length === 0) return '';
  const usp = new URLSearchParams();
  for (const [k, v] of entries) usp.set(k, String(v));
  return '?' + usp.toString();
}

export function esmShModuleUrl(pkg, subpath = '', params = {}) {
  const version = RUNTIME_DEP_VERSIONS[pkg];
  if (!version) {
    throw new Error('[cdn-deps] Unknown runtime dependency: ' + pkg);
  }
  const cleanSubpath = subpath ? (subpath.startsWith('/') ? subpath : '/' + subpath) : '';
  const query = toQuery({ target: ESM_SH_TARGET, ...params });
  return ESM_SH_BASE_URL + '/' + pkg + '@' + version + cleanSubpath + query;
}

export function esmShAssetUrl(pkg, assetPath) {
  const version = RUNTIME_DEP_VERSIONS[pkg];
  if (!version) {
    throw new Error('[cdn-deps] Unknown runtime dependency: ' + pkg);
  }
  const cleanPath = assetPath.startsWith('/') ? assetPath : '/' + assetPath;
  return ESM_SH_BASE_URL + '/' + pkg + '@' + version + cleanPath;
}
`;
    },
  };
}

/**
 * Service Worker compilation plugin API interface
 */
interface SwCompilePluginApi {
  getCompiledSWRCode: () => string;
}

/**
 * Service Worker compilation plugin with typed API
 */
interface SwCompilePlugin extends Plugin {
  api: SwCompilePluginApi;
}

type DevSwOptions = {
  enableDev?: boolean;
};

/**
 * HTML transform plugin for injecting AdSense code conditionally
 *
 * Replaces %%ADSENSE_META%% and %%ADSENSE_SCRIPT%% placeholders in index.html
 * with actual AdSense code when VITE_ENABLE_ADS=true and publisher ID is set.
 *
 * @param env - Environment variables loaded by Vite
 * @returns Vite plugin for HTML transformation
 */
function htmlTransformPlugin(env: Record<string, string>): Plugin {
  return {
    name: 'html-transform',
    transformIndexHtml(html) {
      const enableAds = env.VITE_ENABLE_ADS === 'true';
      const publisherId = env.VITE_ADSENSE_PUBLISHER_ID || '';

      let transformed = html;

      if (enableAds && publisherId) {
        // Inject AdSense meta tag
        const metaTag = `<meta name="google-adsense-account" content="${publisherId}">`;
        transformed = transformed.replace('%%ADSENSE_META%%', metaTag);

        // Inject AdSense script
        const scriptTag = `<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=${publisherId}" crossorigin="anonymous"></script>`;
        transformed = transformed.replace('%%ADSENSE_SCRIPT%%', scriptTag);
      } else {
        // Remove placeholders in development
        transformed = transformed.replace('%%ADSENSE_META%%', '<!-- AdSense disabled -->');
        transformed = transformed.replace('%%ADSENSE_SCRIPT%%', '<!-- AdSense disabled -->');
      }

      return transformed;
    },
  };
}

/**
 * Plugin to dynamically generate public/ads.txt from environment variables
 *
 * Creates ads.txt file required by Google AdSense for ad serving verification.
 * Only generates when VITE_ENABLE_ADS=true and valid publisher ID is provided.
 *
 * @param env - Environment variables loaded by Vite
 * @returns Vite plugin for ads.txt generation
 */
function generateAdsTxtPlugin(env: Record<string, string>): Plugin {
  return {
    name: 'generate-ads-txt',
    buildStart() {
      const enableAds = env.VITE_ENABLE_ADS === 'true';
      const publisherId = env.VITE_ADSENSE_PUBLISHER_ID || '';

      // Only generate ads.txt if ads are enabled and publisher ID is set
      if (enableAds && publisherId && !publisherId.includes('XXXX')) {
        const publicDir = path.join(process.cwd(), 'public');
        const adsTxtPath = path.join(publicDir, 'ads.txt');

        // Extract numeric ID from ca-pub-XXXXXXXXXXXXXXXX
        const numericId = publisherId.replace('ca-pub-', '');
        const adsTxtContent = `google.com, pub-${numericId}, DIRECT, f08c47fec0942fa0\n`;

        try {
          mkdirSync(publicDir, { recursive: true });
          writeFileSync(adsTxtPath, adsTxtContent, 'utf-8');
          console.log(`✓ Generated public/ads.txt with publisher ID: ${publisherId}`);
        } catch (error) {
          console.warn(`⚠ Failed to generate ads.txt:`, error);
        }
      } else {
        console.log('ℹ Skipping ads.txt generation (ads disabled or placeholder ID)');
      }
    },
  };
}

/**
 * Import map plugin for CDN dependencies
 *
 * Generates browser import map for loading dependencies from external CDNs.
 * Enables native ESM imports while reducing bundle size by ~36%.
 *
 * Import maps allow:
 * - import 'solid-js' → resolves to https://esm.sh/solid-js@<version-from-package.json>
 * - import 'modern-gif' → resolves to https://esm.sh/modern-gif@<version-from-package.json>
 *
 * Phase 1: Generates import map but dependencies still bundled
 * Phase 3: Dependencies externalized, import map becomes active
 *
 * @returns Vite plugin for import map injection
 */
function importMapPlugin(): Plugin {
  return {
    name: 'generate-import-map',
    transformIndexHtml(html) {
      // Single source of truth: package.json dependencies.
      const runtimeDeps = readRuntimeDependencies();
      const esmShBase = 'https://esm.sh';
      const targetQuery = '?target=esnext';

      const imports: Record<string, string> = {};

      // Special-case SolidJS because we rely on subpath imports.
      const solidVersion = runtimeDeps['solid-js'];
      if (!solidVersion) {
        throw new Error('[cdn-deps] solid-js version missing from package.json');
      }
      imports['solid-js'] = `${esmShBase}/solid-js@${solidVersion}${targetQuery}`;
      imports['solid-js/web'] = `${esmShBase}/solid-js@${solidVersion}/web${targetQuery}`;
      imports['solid-js/store'] = `${esmShBase}/solid-js@${solidVersion}/store${targetQuery}`;
      imports['solid-js/h'] = `${esmShBase}/solid-js@${solidVersion}/h${targetQuery}`;
      imports['solid-js/html'] = `${esmShBase}/solid-js@${solidVersion}/html${targetQuery}`;

      // All other runtime deps are mapped 1:1 to CDN.
      for (const [pkg, version] of Object.entries(runtimeDeps)) {
        if (pkg === 'solid-js') {
          continue;
        }

        // Load @ffmpeg packages from CDN (Service Worker handles worker CORS)
        // Use jsdelivr for better CORS support
        const isFFmpegPackage = pkg.startsWith('@ffmpeg/');
        if (isFFmpegPackage) {
          imports[pkg] = `https://cdn.jsdelivr.net/npm/${pkg}@${version}/+esm`;
        } else {
          // Use esm.sh for all other packages
          imports[pkg] = `${esmShBase}/${pkg}@${version}${targetQuery}`;
        }
      }

      const importMap = { imports };

      // Create import map script tag
      // Must be placed before any module scripts to be effective
      const scriptTag = `<script type="importmap">${JSON.stringify(importMap, null, 2)}</script>`;

      // Load SRI manifest for integrity hashes
      let sriManifest: {
        entries: Record<string, Record<string, { integrity: string }>>;
      } | null = null;
      try {
        const manifestPath = path.join(process.cwd(), 'public', 'cdn-integrity.json');
        const manifestContent = readFileSync(manifestPath, 'utf-8');
        sriManifest = JSON.parse(manifestContent);
      } catch (_error) {
        console.warn(
          '⚠ SRI manifest not found, modulepreload hints will be generated without integrity hashes'
        );
      }

      // Create modulepreload hints for critical dependencies (Phase 5 + Sprint 3)
      // Preloads modules during idle time to reduce runtime fetch latency
      // Expanded from 3 to 10 dependencies for better cold start performance
      const criticalDeps = [
        'solid-js/web', // Most critical - rendering engine
        'solid-js', // Core reactivity
        'solid-js/store', // State management (used in conversion store)
        'comlink', // Worker communication for FFmpeg
        '@ffmpeg/ffmpeg', // FFmpeg core library (from CDN)
        '@ffmpeg/util', // FFmpeg utilities (from CDN)
        'modern-gif', // GIF encoder
        '@jsquash/webp', // WebP encoder fallback
        'mp4box', // MP4 demuxer
        'web-demuxer', // WebM demuxer
      ] as const;

      const modulePreloadHints = criticalDeps
        .map((dep) => {
          const href = importMap.imports[dep];

          // Skip if dependency is not in import map
          if (!href) {
            console.warn(`⚠ Skipping modulepreload for ${dep} (not found in import map)`);
            return null;
          }

          let integrityAttr = '';

          // Add integrity attribute if SRI manifest is available
          if (sriManifest) {
            const entry = sriManifest.entries[dep];
            // Use jsdelivr for FFmpeg packages, esm.sh for others
            const isFFmpegPackage = dep.startsWith('@ffmpeg/');
            const cdnKey = isFFmpegPackage ? 'jsdelivr' : 'esm.sh';

            if (entry?.[cdnKey]?.integrity) {
              integrityAttr = ` integrity="${entry[cdnKey].integrity}"`;
            }
          }

          return `    <link rel="modulepreload" href="${href}" crossorigin${integrityAttr}>`;
        })
        .filter((hint): hint is string => hint !== null)
        .join('\n');

      // Inject import map and modulepreload hints before closing </head> tag
      const transformed = html.replace(
        '</head>',
        `  ${scriptTag}\n${modulePreloadHints}\n  </head>`
      );

      const validHintsCount = modulePreloadHints ? modulePreloadHints.split('\n').length : 0;
      console.log('ℹ Import map generated with CDN URLs');
      console.log(`ℹ Added modulepreload hints for ${validHintsCount} critical dependencies`);

      return transformed;
    },
  };
}

/**
 * Service Worker compilation plugin
 *
 * Compiles TypeScript service worker files to JavaScript during build.
 * Uses esbuild for fast, reliable compilation with proper minification.
 *
 * Build flow:
 * 1. buildStart: Compile .ts files to .js using esbuild
 * 2. closeBundle: Rename temp files and clean up source .ts files
 *
 * @returns Vite plugin for service worker compilation
 */
function compileServiceWorkerPlugin(options: DevSwOptions = {}): SwCompilePlugin {
  let isDev = false;
  const enableDev = options.enableDev ?? false;
  let compiledSwCode = '';
  let compiledSwrCode = '';
  let devCompilePromise: Promise<void> | null = null;

  const compileServiceWorkerFiles = async (mode: 'dev' | 'build'): Promise<void> => {
    console.log(
      mode === 'dev'
        ? 'ℹ Compiling Service Worker files for dev mode'
        : 'ℹ Compiling Service Worker files...'
    );

    const projectRoot = process.cwd();
    const publicDir = path.join(projectRoot, 'public');
    const tempDir = path.join(projectRoot, '.vite-sw-temp');

    try {
      // Create temp directory outside dist to avoid Vite cleaning
      if (!existsSync(tempDir)) {
        mkdirSync(tempDir, { recursive: true });
      }

      // Compile service-worker.ts
      await esbuild({
        entryPoints: [path.join(publicDir, 'service-worker.ts')],
        outfile: path.join(tempDir, 'service-worker.js'),
        bundle: false,
        format: 'esm',
        target: 'es2020',
        minify: true,
        sourcemap: false,
        platform: 'browser',
        logLevel: 'warning',
      });

      // Compile sw-register.ts
      await esbuild({
        entryPoints: [path.join(publicDir, 'sw-register.ts')],
        outfile: path.join(tempDir, 'sw-register.js'),
        bundle: false,
        format: 'esm',
        target: 'es2020',
        minify: true,
        sourcemap: false,
        platform: 'browser',
        logLevel: 'warning',
      });

      // Read compiled code into memory
      compiledSwCode = readFileSync(path.join(tempDir, 'service-worker.js'), 'utf-8');
      compiledSwCode = injectRuntimeDepsIntoServiceWorker(compiledSwCode);
      compiledSwrCode = readFileSync(path.join(tempDir, 'sw-register.js'), 'utf-8');

      console.log('✓ Service Worker files compiled successfully');
    } catch (error) {
      console.error('✗ Service Worker compilation failed:', error);
      throw error;
    }
  };

  const ensureDevCompilation = async (): Promise<void> => {
    if (!isDev || !enableDev) {
      return;
    }

    if (!devCompilePromise) {
      devCompilePromise = compileServiceWorkerFiles('dev').finally(() => {
        devCompilePromise = null;
      });
    }

    await devCompilePromise;
  };

  return {
    name: 'compile-service-worker',

    configResolved(config) {
      isDev = config.mode === 'development';
    },

    async buildStart() {
      if (isDev && !enableDev) {
        console.log('ℹ Service Worker compilation skipped in dev mode');
        return;
      }

      await compileServiceWorkerFiles(isDev ? 'dev' : 'build');
    },

    writeBundle() {
      if (isDev) return;

      const distDir = path.join(process.cwd(), 'dist');

      try {
        // Write service-worker.js to dist
        writeFileSync(path.join(distDir, 'service-worker.js'), compiledSwCode);
        console.log('✓ Service Worker written to dist/service-worker.js');
      } catch (error) {
        console.error('✗ Failed to write service worker:', error);
        throw error;
      }
    },

    closeBundle() {
      if (isDev) return;

      const projectRoot = process.cwd();
      const tempDir = path.join(projectRoot, '.vite-sw-temp');
      const distDir = path.join(projectRoot, 'dist');

      try {
        // Clean up temp directory
        if (existsSync(tempDir)) {
          rmSync(tempDir, { recursive: true, force: true });
        }

        // Delete source TypeScript files from dist/ if they were copied
        const swTs = path.join(distDir, 'service-worker.ts');
        const swrTs = path.join(distDir, 'sw-register.ts');

        if (existsSync(swTs)) {
          unlinkSync(swTs);
          console.log('✓ Removed service-worker.ts from dist/');
        }

        if (existsSync(swrTs)) {
          unlinkSync(swrTs);
          console.log('✓ Removed sw-register.ts from dist/');
        }
      } catch (error) {
        console.warn('⚠ Service Worker cleanup encountered errors:', error);
      }
    },

    configureServer(server) {
      if (!enableDev) {
        return;
      }

      server.middlewares.use((req, res, next) => {
        const requestPath = req.url?.split('?')[0];

        if (requestPath === '/service-worker.js') {
          void ensureDevCompilation()
            .then(() => {
              res.statusCode = 200;
              res.setHeader('Content-Type', 'text/javascript');
              res.setHeader('Cache-Control', 'no-store');
              res.end(compiledSwCode);
            })
            .catch((error) => {
              console.error('✗ Failed to serve dev service worker:', error);
              res.statusCode = 500;
              res.end('Service worker compilation failed in dev mode.');
            });
          return;
        }

        if (requestPath === '/sw-register.js') {
          void ensureDevCompilation()
            .then(() => {
              res.statusCode = 200;
              res.setHeader('Content-Type', 'text/javascript');
              res.setHeader('Cache-Control', 'no-store');
              res.end(compiledSwrCode);
            })
            .catch((error) => {
              console.error('✗ Failed to serve dev SW register script:', error);
              res.statusCode = 500;
              res.end('SW registration script compilation failed in dev mode.');
            });
          return;
        }

        next();
      });
    },

    // Provide compiled code to injection plugin
    api: {
      getCompiledSWRCode() {
        return compiledSwrCode;
      },
    },
  };
}

/**
 * Service Worker registration injection plugin
 *
 * Inlines service worker registration code into HTML <head>.
 * Avoids additional HTTP request and ensures early registration.
 *
 * Registration code:
 * - Checks for Service Worker API support
 * - Registers /service-worker.js with proper error handling
 * - Handles update notifications
 *
 * @returns Vite plugin for SW registration injection
 */
function injectServiceWorkerPlugin(
  compilePlugin: SwCompilePlugin,
  options: DevSwOptions = {}
): Plugin {
  let isDev = false;
  const enableDev = options.enableDev ?? false;
  let loggedDev = false;

  return {
    name: 'inject-service-worker-registration',

    configResolved(config) {
      isDev = config.mode === 'development';
    },

    transformIndexHtml(html) {
      if (isDev && !enableDev) {
        console.log('ℹ Service Worker registration skipped in dev mode');
        return html;
      }

      if (isDev && enableDev && !loggedDev) {
        console.log('ℹ Service Worker registration enabled in dev mode');
        loggedDev = true;
      }

      let registrationCode = '';

      // Get compiled code from compilation plugin API
      const compiledCode = compilePlugin.api.getCompiledSWRCode();

      if (compiledCode) {
        registrationCode = `
<script type="module">
// Service Worker Registration (inlined for immediate execution)
${compiledCode}

// Auto-register on page load
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    globalThis.registerServiceWorker?.();
  });
} else {
  globalThis.registerServiceWorker?.();
}
</script>`;
      } else {
        // Fallback registration
        registrationCode = `
<script type="module">
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try {
      const registration = await navigator.serviceWorker.register('/service-worker.js', {
        scope: '/',
        type: 'classic',
      });
      console.log('[SW] Registered successfully:', registration.scope);

      setInterval(() => {
        registration.update().catch(() => {});
      }, 60 * 60 * 1000);
    } catch (error) {
      console.error('[SW] Registration failed:', error);
    }
  });
} else {
  console.warn('[SW] Service Workers not supported');
}
</script>`;
      }

      const transformed = html.replace('</head>', `  ${registrationCode}\n  </head>`);
      console.log('✓ Service Worker registration injected into HTML');

      return transformed;
    },
  };
}

export default defineConfig(({ mode }) => {
  // Load environment variables based on mode (development/production)
  const env = loadEnv(mode, process.cwd(), '');

  // Reuse a single plugin instance across both main and worker builds.
  const cdnDepsPlugin = cdnDepsVirtualModulePlugin();

  const runtimeDeps = readRuntimeDependencies();
  const runtimeDepNames = Object.keys(runtimeDeps);
  const isExternalRuntimeDep = (id: string): boolean => {
    // All runtime dependencies are externalized to CDN
    // Service Worker handles worker CORS via proxy pattern
    return runtimeDepNames.some((dep) => id === dep || id.startsWith(`${dep}/`));
  };

  // Create service worker compilation plugin (needed by injection plugin)
  const enableSwDev = env.VITE_ENABLE_SW_DEV === 'true';
  const swCompilePlugin = compileServiceWorkerPlugin({
    enableDev: enableSwDev,
  });

  return {
    // Vite plugins configuration
    plugins: [
      cdnDepsPlugin, // virtual:cdn-deps for consistent CDN URL generation
      solid(), // SolidJS JSX transformation and HMR
      htmlTransformPlugin(env), // Inject AdSense code conditionally
      generateAdsTxtPlugin(env), // Generate ads.txt for AdSense verification
      importMapPlugin(), // Generate import map for CDN dependencies (Phase 1)
      swCompilePlugin, // Compile service worker TypeScript to JavaScript
      injectServiceWorkerPlugin(swCompilePlugin, { enableDev: enableSwDev }),
      // Generate pre-cache manifest for Service Worker (Phase 5)
      {
        name: 'generate-precache-manifest',
        closeBundle() {
          const distDir = path.join(process.cwd(), 'dist');

          // Recursively collect all files
          const collectFiles = (dir: string, baseDir: string): string[] => {
            const entries = readdirSync(dir, { withFileTypes: true });
            const files: string[] = [];

            for (const entry of entries) {
              const fullPath = path.join(dir, entry.name);
              if (entry.isDirectory()) {
                files.push(...collectFiles(fullPath, baseDir));
              } else if (entry.isFile() && /\.(js|css|html)$/.test(entry.name)) {
                const relativePath = path.relative(baseDir, fullPath);
                files.push(`/${relativePath}`);
              }
            }

            return files;
          };

          const precacheUrls = collectFiles(distDir, distDir).filter(
            (p) => !p.includes('service-worker')
          ); // Exclude SW itself

          // Inject into Service Worker
          const swPath = path.join(distDir, 'service-worker.js');
          if (existsSync(swPath)) {
            let swContent = readFileSync(swPath, 'utf-8');
            // Replace the magic string placeholder with actual URLs
            swContent = swContent.replace('"PRECACHE_MANIFEST"', JSON.stringify(precacheUrls));
            writeFileSync(swPath, swContent);
            console.log(`ℹ Injected ${precacheUrls.length} pre-cache URLs into Service Worker`);
          }
        },
      },
      visualizer({
        // Bundle analysis tool - generates dist/stats.html
        filename: 'dist/stats.html',
        gzipSize: true, // Calculate gzipped bundle sizes
        brotliSize: true, // Calculate brotli-compressed sizes
      }) as PluginOption,
    ],

    // Import path aliases (matches tsconfig.json paths)
    // Enables cleaner imports: '@components/...' instead of '../../components/...'
    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src'),
        '@components': path.resolve(__dirname, './src/components'),
        '@services': path.resolve(__dirname, './src/services'),
        '@utils': path.resolve(__dirname, './src/utils'),
        '@stores': path.resolve(__dirname, './src/stores'),
        '@t': path.resolve(__dirname, './src/types'),
      },
    },

    // Ensure workers are emitted as ES modules.
    // Some worker dependencies (e.g., WASM packages) trigger code-splitting,
    // which is not supported with IIFE/UMD worker output formats.
    worker: {
      format: 'es',
      plugins: () => [cdnDepsPlugin],
    },

    // Development server configuration
    server: {
      // Required headers for SharedArrayBuffer support (FFmpeg.wasm multithreading)
      // Cross-origin isolation enables ffmpeg-core-mt.wasm worker threads
      headers: {
        'Cross-Origin-Embedder-Policy': 'require-corp',
        'Cross-Origin-Opener-Policy': 'same-origin',
      },
    },

    // Preview server configuration (same isolation requirements as dev)
    preview: {
      headers: {
        'Cross-Origin-Embedder-Policy': 'require-corp',
        'Cross-Origin-Opener-Policy': 'same-origin',
      },
    },

    // Dependency optimization configuration
    // Exclude @ffmpeg/ffmpeg from pre-bundling to prevent worker URL rewriting issues
    // Vite's dependency pre-bundling can break FFmpeg's internal worker module resolution
    // Include solid-js for faster dev server startup
    optimizeDeps: {
      exclude: ['@ffmpeg/ffmpeg'],
      include: ['solid-js/web', 'solid-js/store'],
    },

    // Production build configuration
    build: {
      target: 'esnext', // Target modern browsers with ESNext features
      chunkSizeWarningLimit: 1000, // Increase limit for FFmpeg bundles (1MB)
      cssCodeSplit: true, // Enable CSS code splitting for better caching
      sourcemap: false, // Disable source maps for smaller bundle
      minify: 'esbuild', // Use esbuild for faster minification

      rollupOptions: {
        // Externalize ALL runtime deps so the production bundle contains app code only.
        // Dependencies are loaded via import map (document) or explicit CDN URLs (workers).
        external: (id) => isExternalRuntimeDep(id),

        output: {
          format: 'es', // ES module format for tree-shaking

          // Optimized file naming for better caching
          entryFileNames: 'assets/[name].[hash].js',
          chunkFileNames: 'assets/[name].[hash].js',
          assetFileNames: 'assets/[name].[hash].[ext]',

          // Improve tree-shaking
          preserveModules: false,
          exports: 'auto',

          // Compact output for smaller bundles
          compact: true,

          // Manual code splitting for optimal long-term caching
          // Separates stable vendor/service code from frequently-changing app code
          // Service bundles change less frequently than main app, enabling better caching
          manualChunks(id) {
            // Note: FFmpeg packages are loaded from CDN (not bundled)

            // Shared internal modules used by multiple service bundles.
            // Keep these inside the conversion bundle to avoid circular chunk warnings
            // between services-shared and services-conversion.
            // Also includes CDN utilities (cdn-config, cdn-url-builder, cdn-health-tracker)
            // that are used by both FFmpeg and unified-preloader.
            if (
              id.includes('src/utils/') ||
              id.includes('src/services/shared/') ||
              id.includes('cdn-config') ||
              id.includes('cdn-url-builder') ||
              id.includes('cdn-health-tracker') ||
              id.includes('cdn-loader')
            ) {
              return 'services-conversion';
            }

            // Conversion services - ALL conversion-related modules in one chunk
            // Includes: ffmpeg-service, cpu-path, ffmpeg, cdn, orchestration,
            // webcodecs, video-pipeline, encoders, sw
            // These are tightly coupled (webcodecs-conversion-service imports ffmpegService,
            // unified-preloader imports ffmpegService) so must be in same chunk
            // to avoid circular chunk dependencies.
            if (
              id.includes('ffmpeg-service') ||
              id.includes('src/services/cpu-path/') ||
              id.includes('src/services/ffmpeg/') ||
              id.includes('src/services/cdn/') ||
              id.includes('src/services/orchestration') ||
              id.includes('src/services/webcodecs') ||
              id.includes('src/services/video-pipeline') ||
              id.includes('src/services/encoders') ||
              id.includes('src/services/sw/')
            ) {
              return 'services-conversion';
            }

            // UI components - can be lazy-loaded
            if (
              id.includes('FileDropzone') ||
              id.includes('ConversionProgress') ||
              id.includes('ProgressBar')
            ) {
              return 'components-ui';
            }
          },
        },
      },
    },
  };
});
