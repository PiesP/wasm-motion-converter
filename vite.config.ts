import {
  existsSync,
  mkdirSync,
  readdirSync,
  readFileSync,
  rmSync,
  unlinkSync,
  writeFileSync,
} from 'node:fs';
import path from 'node:path';
import { build as esbuild } from 'esbuild';
import { visualizer } from 'rollup-plugin-visualizer';
import type { Plugin, PluginOption } from 'vite';
import { defineConfig, loadEnv } from 'vite';
import solid from 'vite-plugin-solid';

function readRuntimeDependencies(): Record<string, string> {
  const pkgJsonPath = path.join(process.cwd(), 'package.json');
  const raw = readFileSync(pkgJsonPath, 'utf-8');

  const pkg = JSON.parse(raw) as {
    dependencies?: Record<string, string>;
    cdnDependencies?: Record<string, string>;
  };
  const deps = pkg?.dependencies ?? {};
  const cdnDeps = pkg?.cdnDependencies ?? {};

  const normalizeVersion = (spec: string): string =>
    String(spec)
      .trim()
      .replace(/^[\^~]/, '');

  const normalized: Record<string, string> = {};
  const addDeps = (source: Record<string, string>, label: string): void => {
    for (const [name, spec] of Object.entries(source)) {
      const version = normalizeVersion(spec);
      const existing = normalized[name];
      if (existing && existing !== version) {
        throw new Error(
          `[cdn-deps] Version mismatch for ${name}: ${existing} (previous) vs ${version} (${label})`
        );
      }

      normalized[name] = version;
    }
  };

  addDeps(deps, 'dependencies');
  addDeps(cdnDeps, 'cdnDependencies');

  return normalized;
}

function injectRuntimeDepsIntoServiceWorker(code: string): string {
  const runtimeDeps = readRuntimeDependencies();
  const json = JSON.stringify(runtimeDeps);
  const escaped = json.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  const replaced = code.replaceAll('__RUNTIME_DEP_VERSIONS__', escaped);

  if (replaced === code) {
    console.warn('[cdn-deps] Service worker runtime dependency placeholder not replaced');
  }

  return replaced;
}

function cdnDepsVirtualModulePlugin(): Plugin {
  const virtualId = 'virtual:cdn-deps';
  const resolvedVirtualId = `\0${virtualId}`;

  const runtimeDeps = readRuntimeDependencies();
  const baseUrl = 'https://esm.sh';
  const target = 'esnext';

  return {
    name: 'cdn-deps-virtual-module',
    resolveId(id) {
      if (id === virtualId) {
        return resolvedVirtualId;
      }
      return undefined;
    },
    load(id) {
      if (id !== resolvedVirtualId) {
        return undefined;
      }

      return `// Generated by vite.config.ts (cdn-deps-virtual-module)
export const RUNTIME_DEP_VERSIONS = ${JSON.stringify(runtimeDeps, null, 2)};
export const ESM_SH_BASE_URL = ${JSON.stringify(baseUrl)};
export const ESM_SH_TARGET = ${JSON.stringify(target)};

/**
 * Unified CDN provider configuration (matches cdn-config.ts)
 * Used for runtime CDN operations and debugging
 */
export const CDN_PROVIDERS = [
  { name: 'esm.sh', hostname: 'esm.sh', baseUrl: 'https://esm.sh', priority: 1, timeout: 15000, enabled: true },
  { name: 'jsdelivr', hostname: 'cdn.jsdelivr.net', baseUrl: 'https://cdn.jsdelivr.net', priority: 2, timeout: 15000, enabled: true },
  { name: 'unpkg', hostname: 'unpkg.com', baseUrl: 'https://unpkg.com', priority: 3, timeout: 15000, enabled: true },
  { name: 'skypack', hostname: 'cdn.skypack.dev', baseUrl: 'https://cdn.skypack.dev', priority: 4, timeout: 15000, enabled: true },
];

/**
 * Gets all enabled CDN providers
 * @returns Array of enabled CDN providers
 */
export function getCDNProviders() {
  return CDN_PROVIDERS.filter(p => p.enabled);
}

function toQuery(params) {
  if (!params) return '';
  const entries = Object.entries(params).filter(([, v]) => v != null && v !== '');
  if (entries.length === 0) return '';
  const usp = new URLSearchParams();
  for (const [k, v] of entries) usp.set(k, String(v));
  return '?' + usp.toString();
}

export function esmShModuleUrl(pkg, subpath = '', params = {}) {
  const version = RUNTIME_DEP_VERSIONS[pkg];
  if (!version) {
    throw new Error('[cdn-deps] Unknown runtime dependency: ' + pkg);
  }
  const cleanSubpath = subpath ? (subpath.startsWith('/') ? subpath : '/' + subpath) : '';
  const query = toQuery({ target: ESM_SH_TARGET, ...params });
  return ESM_SH_BASE_URL + '/' + pkg + '@' + version + cleanSubpath + query;
}

export function esmShAssetUrl(pkg, assetPath) {
  const version = RUNTIME_DEP_VERSIONS[pkg];
  if (!version) {
    throw new Error('[cdn-deps] Unknown runtime dependency: ' + pkg);
  }
  const cleanPath = assetPath.startsWith('/') ? assetPath : '/' + assetPath;
  return ESM_SH_BASE_URL + '/' + pkg + '@' + version + cleanPath;
}
`;
    },
  };
}

interface SwCompilePluginApi {
  getCompiledSWRCode: () => string;
}

interface SwCompilePlugin extends Plugin {
  api: SwCompilePluginApi;
}

type DevSwOptions = {
  enableDev?: boolean;
};

function importMapPlugin(): Plugin {
  return {
    name: 'generate-import-map',
    transformIndexHtml(html) {
      const runtimeDeps = readRuntimeDependencies();
      const esmShBase = 'https://esm.sh';
      const targetQuery = '?target=esnext';

      const imports: Record<string, string> = {};

      const solidVersion = runtimeDeps['solid-js'];
      if (!solidVersion) {
        throw new Error('[cdn-deps] solid-js version missing from package.json');
      }
      imports['solid-js'] = `${esmShBase}/solid-js@${solidVersion}${targetQuery}`;
      imports['solid-js/web'] = `${esmShBase}/solid-js@${solidVersion}/web${targetQuery}`;
      imports['solid-js/store'] = `${esmShBase}/solid-js@${solidVersion}/store${targetQuery}`;
      imports['solid-js/h'] = `${esmShBase}/solid-js@${solidVersion}/h${targetQuery}`;
      imports['solid-js/html'] = `${esmShBase}/solid-js@${solidVersion}/html${targetQuery}`;

      for (const [pkg, version] of Object.entries(runtimeDeps)) {
        if (pkg === 'solid-js') {
          continue;
        }

        const isFFmpegPackage = pkg.startsWith('@ffmpeg/');
        if (isFFmpegPackage) {
          imports[pkg] = `https://cdn.jsdelivr.net/npm/${pkg}@${version}/+esm`;
        } else {
          imports[pkg] = `${esmShBase}/${pkg}@${version}${targetQuery}`;
        }
      }

      const importMap = { imports };

      const scriptTag = `<script type="importmap">${JSON.stringify(importMap, null, 2)}</script>`;

      let sriManifest: {
        entries: Record<string, Record<string, { integrity: string }>>;
      } | null = null;
      try {
        const manifestPath = path.join(process.cwd(), 'public', 'cdn-integrity.json');
        const manifestContent = readFileSync(manifestPath, 'utf-8');
        sriManifest = JSON.parse(manifestContent);
      } catch (_error) {
        console.warn(
          '⚠ SRI manifest not found, modulepreload hints will be generated without integrity hashes'
        );
      }

      const criticalDeps = [
        'solid-js/web',
        'solid-js',
        'solid-js/store',
        'comlink',
        '@ffmpeg/ffmpeg',
        '@ffmpeg/util',
        'modern-gif',
        'mp4box',
        'web-demuxer',
      ] as const;

      const modulePreloadHints = criticalDeps
        .map((dep) => {
          const href = importMap.imports[dep];

          if (!href) {
            console.warn(`⚠ Skipping modulepreload for ${dep} (not found in import map)`);
            return null;
          }

          let integrityAttr = '';

          if (sriManifest) {
            const entry = sriManifest.entries[dep];
            const isFFmpegPackage = dep.startsWith('@ffmpeg/');
            const cdnKey = isFFmpegPackage ? 'jsdelivr' : 'esm.sh';

            if (entry?.[cdnKey]?.integrity) {
              integrityAttr = ` integrity="${entry[cdnKey].integrity}"`;
            }
          }

          return `    <link rel="modulepreload" href="${href}" crossorigin${integrityAttr}>`;
        })
        .filter((hint): hint is string => hint !== null)
        .join('\n');

      const transformed = html.replace(
        '</head>',
        `  ${scriptTag}\n${modulePreloadHints}\n  </head>`
      );

      const validHintsCount = modulePreloadHints ? modulePreloadHints.split('\n').length : 0;
      console.log('ℹ Import map generated with CDN URLs');
      console.log(`ℹ Added modulepreload hints for ${validHintsCount} critical dependencies`);

      return transformed;
    },
  };
}

function compileServiceWorkerPlugin(options: DevSwOptions = {}): SwCompilePlugin {
  let isDev = false;
  const enableDev = options.enableDev ?? false;
  let compiledSwCode = '';
  let compiledSwrCode = '';
  let devCompilePromise: Promise<void> | null = null;

  const compileServiceWorkerFiles = async (mode: 'dev' | 'build'): Promise<void> => {
    console.log(
      mode === 'dev'
        ? 'ℹ Compiling Service Worker files for dev mode'
        : 'ℹ Compiling Service Worker files...'
    );

    const projectRoot = process.cwd();
    const publicDir = path.join(projectRoot, 'public');
    const tempDir = path.join(projectRoot, '.vite-sw-temp');

    try {
      if (!existsSync(tempDir)) {
        mkdirSync(tempDir, { recursive: true });
      }

      await esbuild({
        entryPoints: [path.join(publicDir, 'service-worker.ts')],
        outfile: path.join(tempDir, 'service-worker.js'),
        bundle: false,
        format: 'esm',
        target: 'es2020',
        minify: true,
        sourcemap: false,
        platform: 'browser',
        logLevel: 'warning',
      });

      await esbuild({
        entryPoints: [path.join(publicDir, 'sw-register.ts')],
        outfile: path.join(tempDir, 'sw-register.js'),
        bundle: false,
        format: 'esm',
        target: 'es2020',
        minify: true,
        sourcemap: false,
        platform: 'browser',
        logLevel: 'warning',
      });

      compiledSwCode = readFileSync(path.join(tempDir, 'service-worker.js'), 'utf-8');
      compiledSwCode = injectRuntimeDepsIntoServiceWorker(compiledSwCode);
      compiledSwrCode = readFileSync(path.join(tempDir, 'sw-register.js'), 'utf-8');

      console.log('✓ Service Worker files compiled successfully');
    } catch (error) {
      console.error('✗ Service Worker compilation failed:', error);
      throw error;
    }
  };

  const ensureDevCompilation = async (): Promise<void> => {
    if (!isDev || !enableDev) {
      return;
    }

    if (!devCompilePromise) {
      devCompilePromise = compileServiceWorkerFiles('dev').finally(() => {
        devCompilePromise = null;
      });
    }

    await devCompilePromise;
  };

  return {
    name: 'compile-service-worker',

    configResolved(config) {
      isDev = config.mode === 'development';
    },

    async buildStart() {
      if (isDev && !enableDev) {
        console.log('ℹ Service Worker compilation skipped in dev mode');
        return;
      }

      await compileServiceWorkerFiles(isDev ? 'dev' : 'build');
    },

    writeBundle() {
      if (isDev) return;

      const distDir = path.join(process.cwd(), 'dist');

      try {
        // Write service-worker.js to dist
        writeFileSync(path.join(distDir, 'service-worker.js'), compiledSwCode);
        console.log('✓ Service Worker written to dist/service-worker.js');
      } catch (error) {
        console.error('✗ Failed to write service worker:', error);
        throw error;
      }
    },

    closeBundle() {
      if (isDev) return;

      const projectRoot = process.cwd();
      const tempDir = path.join(projectRoot, '.vite-sw-temp');
      const distDir = path.join(projectRoot, 'dist');

      try {
        // Clean up temp directory
        if (existsSync(tempDir)) {
          rmSync(tempDir, { recursive: true, force: true });
        }

        // Delete source TypeScript files from dist/ if they were copied
        const swTs = path.join(distDir, 'service-worker.ts');
        const swrTs = path.join(distDir, 'sw-register.ts');

        if (existsSync(swTs)) {
          unlinkSync(swTs);
          console.log('✓ Removed service-worker.ts from dist/');
        }

        if (existsSync(swrTs)) {
          unlinkSync(swrTs);
          console.log('✓ Removed sw-register.ts from dist/');
        }
      } catch (error) {
        console.warn('⚠ Service Worker cleanup encountered errors:', error);
      }
    },

    configureServer(server) {
      if (!enableDev) {
        return;
      }

      server.middlewares.use((req, res, next) => {
        const requestPath = req.url?.split('?')[0];

        if (requestPath === '/service-worker.js') {
          void ensureDevCompilation()
            .then(() => {
              res.statusCode = 200;
              res.setHeader('Content-Type', 'text/javascript');
              res.setHeader('Cache-Control', 'no-store');
              res.end(compiledSwCode);
            })
            .catch((error) => {
              console.error('✗ Failed to serve dev service worker:', error);
              res.statusCode = 500;
              res.end('Service worker compilation failed in dev mode.');
            });
          return;
        }

        if (requestPath === '/sw-register.js') {
          void ensureDevCompilation()
            .then(() => {
              res.statusCode = 200;
              res.setHeader('Content-Type', 'text/javascript');
              res.setHeader('Cache-Control', 'no-store');
              res.end(compiledSwrCode);
            })
            .catch((error) => {
              console.error('✗ Failed to serve dev SW register script:', error);
              res.statusCode = 500;
              res.end('SW registration script compilation failed in dev mode.');
            });
          return;
        }

        next();
      });
    },

    api: {
      getCompiledSWRCode() {
        return compiledSwrCode;
      },
    },
  };
}

function injectServiceWorkerPlugin(
  compilePlugin: SwCompilePlugin,
  options: DevSwOptions = {}
): Plugin {
  let isDev = false;
  const enableDev = options.enableDev ?? false;
  let loggedDev = false;

  return {
    name: 'inject-service-worker-registration',

    configResolved(config) {
      isDev = config.mode === 'development';
    },

    transformIndexHtml(html) {
      if (isDev && !enableDev) {
        console.log('ℹ Service Worker registration skipped in dev mode');
        return html;
      }

      if (isDev && enableDev && !loggedDev) {
        console.log('ℹ Service Worker registration enabled in dev mode');
        loggedDev = true;
      }

      let registrationCode = '';

      const compiledCode = compilePlugin.api.getCompiledSWRCode();

      if (compiledCode) {
        registrationCode = `
<script type="module">
// Service Worker Registration (inlined for immediate execution)
${compiledCode}

// Auto-register on page load
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    globalThis.registerServiceWorker?.();
  });
} else {
  globalThis.registerServiceWorker?.();
}
</script>`;
      } else {
        registrationCode = `
<script type="module">
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try {
      const registration = await navigator.serviceWorker.register('/service-worker.js', {
        scope: '/',
        type: 'classic',
      });
      console.log('[SW] Registered successfully:', registration.scope);

      setInterval(() => {
        registration.update().catch(() => {});
      }, 60 * 60 * 1000);
    } catch (error) {
      console.error('[SW] Registration failed:', error);
    }
  });
} else {
  console.warn('[SW] Service Workers not supported');
}
</script>`;
      }

      const transformed = html.replace('</head>', `  ${registrationCode}\n  </head>`);
      console.log('✓ Service Worker registration injected into HTML');

      return transformed;
    },
  };
}

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), '');

  const cdnDepsPlugin = cdnDepsVirtualModulePlugin();

  const runtimeDeps = readRuntimeDependencies();
  const runtimeDepNames = Object.keys(runtimeDeps);
  const isExternalRuntimeDep = (id: string): boolean => {
    // All runtime dependencies are externalized to CDN
    // Service Worker handles worker CORS via proxy pattern
    return runtimeDepNames.some((dep) => id === dep || id.startsWith(`${dep}/`));
  };

  const enableSwDev = env.VITE_ENABLE_SW_DEV === 'true';
  const swCompilePlugin = compileServiceWorkerPlugin({
    enableDev: enableSwDev,
  });

  return {
    plugins: [
      cdnDepsPlugin,
      solid(),
      importMapPlugin(),
      swCompilePlugin,
      injectServiceWorkerPlugin(swCompilePlugin, { enableDev: enableSwDev }),
      {
        name: 'generate-precache-manifest',
        closeBundle() {
          const distDir = path.join(process.cwd(), 'dist');

          const collectFiles = (dir: string, baseDir: string): string[] => {
            const entries = readdirSync(dir, { withFileTypes: true });
            const files: string[] = [];

            for (const entry of entries) {
              const fullPath = path.join(dir, entry.name);
              if (entry.isDirectory()) {
                files.push(...collectFiles(fullPath, baseDir));
              } else if (entry.isFile() && /\.(js|css|html)$/.test(entry.name)) {
                const relativePath = path.relative(baseDir, fullPath);
                files.push(`/${relativePath}`);
              }
            }

            return files;
          };

          const precacheUrls = collectFiles(distDir, distDir).filter(
            (p) => !p.includes('service-worker')
          );

          const swPath = path.join(distDir, 'service-worker.js');
          if (existsSync(swPath)) {
            let swContent = readFileSync(swPath, 'utf-8');
            swContent = swContent.replace('"PRECACHE_MANIFEST"', JSON.stringify(precacheUrls));
            writeFileSync(swPath, swContent);
            console.log(`ℹ Injected ${precacheUrls.length} pre-cache URLs into Service Worker`);
          }
        },
      },
      visualizer({
        filename: 'dist/stats.html',
        gzipSize: true,
        brotliSize: true,
      }) as PluginOption,
    ],

    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src'),
        '@components': path.resolve(__dirname, './src/components'),
        '@services': path.resolve(__dirname, './src/services'),
        '@utils': path.resolve(__dirname, './src/utils'),
        '@stores': path.resolve(__dirname, './src/stores'),
        '@t': path.resolve(__dirname, './src/types'),
      },
    },

    worker: {
      format: 'es',
      plugins: () => [cdnDepsPlugin],
    },

    server: {
      headers: {
        'Cross-Origin-Embedder-Policy': 'require-corp',
        'Cross-Origin-Opener-Policy': 'same-origin',
      },
    },

    preview: {
      headers: {
        'Cross-Origin-Embedder-Policy': 'require-corp',
        'Cross-Origin-Opener-Policy': 'same-origin',
      },
    },

    optimizeDeps: {
      exclude: ['@ffmpeg/ffmpeg'],
      include: ['solid-js/web', 'solid-js/store'],
    },

    build: {
      target: 'esnext',
      chunkSizeWarningLimit: 1000,
      cssCodeSplit: true,
      sourcemap: false,
      minify: 'esbuild',

      rollupOptions: {
        external: (id) => isExternalRuntimeDep(id),

        output: {
          format: 'es',
          entryFileNames: 'assets/[name].[hash].js',
          chunkFileNames: 'assets/[name].[hash].js',
          assetFileNames: 'assets/[name].[hash].[ext]',
          preserveModules: false,
          exports: 'auto',
          compact: true,
          manualChunks(id) {
            if (
              id.includes('src/utils/') ||
              id.includes('src/services/shared/') ||
              id.includes('cdn-config') ||
              id.includes('cdn-url-builder') ||
              id.includes('cdn-health-tracker') ||
              id.includes('cdn-loader')
            ) {
              return 'services-conversion';
            }

            if (
              id.includes('ffmpeg-service') ||
              id.includes('src/services/cpu-path/') ||
              id.includes('src/services/ffmpeg/') ||
              id.includes('src/services/cdn/') ||
              id.includes('src/services/orchestration') ||
              id.includes('src/services/webcodecs') ||
              id.includes('src/services/video-pipeline') ||
              id.includes('src/services/encoders') ||
              id.includes('src/services/sw/')
            ) {
              return 'services-conversion';
            }

            if (
              id.includes('FileDropzone') ||
              id.includes('ConversionProgress') ||
              id.includes('ProgressBar')
            ) {
              return 'components-ui';
            }
          },
        },
      },
    },
  };
});
